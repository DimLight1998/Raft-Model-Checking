MODULE node(nodeID, isNewest, eventType, eventSenderID, eventReceiverID, oracleSenderIsNewer, oracleWinMajority)
VAR
  role: {Follower, Candidate, Leader};
  votedFor: -1 .. ⟨!echo $((⟨=numNode⟩ - 1))⟩;
ASSIGN
  init(role) := Follower;
  init(votedFor) := -1;

  next(role) :=
    case
      next(eventType) = Noop: role;
      next(eventType) = Timeout:
        case
          next(eventSenderID) = nodeID: Candidate;
          next(eventSenderID) != nodeID: role;
        esac;
      next(eventType) = VoteReq:
        case
          next(eventReceiverID) = nodeID & next(oracleSenderIsNewer): Follower;
          TRUE: role;
        esac;
      next(eventType) = VoteRsp:
        case
          next(eventReceiverID) = nodeID & next(oracleSenderIsNewer): Follower;
          next(eventReceiverID) = nodeID & next(oracleWinMajority): Leader;
          TRUE: role;
        esac;
    esac;
  next(votedFor) :=
    case
      next(role) = Candidate: nodeID;
      next(eventType) = VoteReq & next(eventReceiverID) = nodeID & next(oracleSenderIsNewer): next(eventSenderID);
      TRUE: votedFor;
    esac;


MODULE main
VAR
  eventType: {Noop, Timeout, VoteReq, VoteRsp};
  eventSenderID: 0 .. ⟨!echo $((⟨=numNode⟩ - 1))⟩;
  eventReceiverID: 0 .. ⟨!echo $((⟨=numNode⟩ - 1))⟩;
  oracleSenderIsNewer: boolean;
  oracleWinMajority: boolean;
  ⟨⟨⟨ python
  lines = []
  for i in range(⟨=numNode⟩):
    lines.append(f"isNewest{i}: boolean;")
    lines.append(f"voteAcpt{i}: boolean;")
    lines.append(f"node{i}: node({i}, isNewest{i}, eventType, eventSenderID, eventReceiverID, oracleSenderIsNewer, oracleWinMajority);")
  print("\n".join(lines), end="")
  ⟩⟩⟩
ASSIGN
  init(eventType) := Noop;
  init(eventSenderID) := 0;
  init(eventReceiverID) := 0;
  init(oracleSenderIsNewer) := FALSE;
  init(oracleWinMajority) := FALSE;

  next(eventType) :=
    case
      ⟨⟨⟨ python
      numNode = ⟨=numNode⟩
      candidateCases = "\n  " + ",\n  ".join([f"node{i}.role = Candidate" for i in range(numNode)]) + "\n"
      followerCases = "\n  " + ",\n  ".join([f"node{i}.role = Follower & node{i}.votedFor != -1" for i in range(numNode)]) + "\n"
      print(f"count({candidateCases}) = 0 & count({followerCases}) = 0 : {{Timeout, Noop}};")
      print(f"count({candidateCases}) = 0 & count({followerCases}) > 0 : {{Timeout, Noop, VoteRsp}};")
      print(f"count({candidateCases}) > 0 & count({followerCases}) = 0 : {{Timeout, Noop, VoteReq}};")
      print(f"count({candidateCases}) > 0 & count({followerCases}) > 0 : {{Timeout, Noop, VoteReq, VoteRsp}};", end="")
      ⟩⟩⟩
    esac;
  next(eventSenderID) :=
    case
      ⟨⟨⟨ python
      lines = []
      for i in range(0, ⟨=numNode⟩):
        lines.append(f"next(eventType) = VoteReq & node{i}.role = Candidate : {i};")
      for i in range(0, ⟨=numNode⟩):
        lines.append(f"next(eventType) = VoteRsp & node{i}.role = Follower & node{i}.votedFor != -1 : {i};")
      print("\n".join(lines), end="")
      ⟩⟩⟩
      next(eventType) = Timeout : {⟨!python -c 'print(", ".join(map(str, range(⟨=numNode⟩))))'⟩};
      next(eventType) = Noop    : {⟨!python -c 'print(", ".join(map(str, range(⟨=numNode⟩))))'⟩};
      TRUE                      : {⟨!python -c 'print(", ".join(map(str, range(⟨=numNode⟩))))'⟩};
    esac;
  next(eventReceiverID) :=
    case
      ⟨⟨⟨ python
      lines = []
      numNode = ⟨=numNode⟩
      lines += [f"next(eventType) = VoteReq & node{i}.role = Candidate : {{" + ", ".join(map(str, list(range(i + 1, numNode)) + list(range(i)))) + "};" for i in range(numNode)]
      lines += [f"next(eventType) = VoteRsp & node{i}.role = Follower & node{i}.votedFor != -1 : node{i}.votedFor;" for i in range(numNode)]
      print("\n".join(lines), end="")
      ⟩⟩⟩
      next(eventType) = Timeout : {⟨!python -c 'print(", ".join(map(str, range(⟨=numNode⟩))))'⟩};
      next(eventType) = Noop    : 0;
      TRUE                      : 0;
    esac;
  next(oracleSenderIsNewer) :=
    case
      ⟨⟨⟨ python
      lines = []
      numNode = ⟨=numNode⟩
      for i in range(numNode):
        for j in range(numNode):
          if i != j:
            lines.append(f"next(eventType) = VoteReq & next(eventSenderID) = {i} & next(eventReceiverID) = {j} & isNewest{i} & !isNewest{j} : TRUE;")
            lines.append(f"next(eventType) = VoteRsp & next(eventSenderID) = {i} & next(eventReceiverID) = {j} & isNewest{i} & !isNewest{j} : TRUE;")
      print("\n".join(lines), end="")
      ⟩⟩⟩
      TRUE : FALSE;
    esac;
  next(oracleWinMajority) :=
    case
      ⟨⟨⟨ python
      lines = []
      numNode = ⟨=numNode⟩
      numMajor = int(numNode / 2) if numNode % 2 == 0 else int(numNode / 2) + 1
      for candidate in range(numNode):
        conds = [f"\n    node{voter}.votedFor = {candidate} & voteAcpt{voter} & isNewest{voter}" for voter in range(numNode)]
        lines.append(f"next(eventType) = VoteRsp & next(eventReceiverID) = {candidate} & count({','.join(conds)}\n  ) >= {numMajor}: TRUE;")
      print("\n".join(lines), end="")
      ⟩⟩⟩
      TRUE : FALSE;
    esac;

  ⟨⟨⟨ python
  print("\n".join([f"init(isNewest{i}) := TRUE;" for i in range(⟨=numNode⟩)]), end="")
  ⟩⟩⟩

  ⟨⟨⟨ python
  numNode = ⟨=numNode⟩
  for i in range(numNode):
    excluded = list(range(i + 1, numNode)) + list(range(i))
    timeoutCases = "\n".join(map(lambda l: "  " * 4 + l, [f"next(eventSenderID) = {j} : isNewest{j} ? FALSE : isNewest{i};" for j in excluded]))
    reqRspCases = "\n".join(map(lambda l: "  " * 4 + l, [f"next(eventReceiverID) = {i} & next(eventSenderID) = {j} & isNewest{j}: TRUE;" for j in excluded]))
    template = \
  f"""
  next(isNewest{i}) :=
    case
      next(eventType) = Timeout:
        case
          next(eventSenderID) = {i} &  isNewest{i} : TRUE;
          next(eventSenderID) = {i} & !isNewest{i} : {{TRUE, FALSE}};
  {timeoutCases}
        esac;
      next(eventType) = VoteReq:
        case
  {reqRspCases}
          TRUE: isNewest{i};
        esac;
      next(eventType) = VoteRsp:
        case
  {reqRspCases}
          TRUE: isNewest{i};
        esac;
      next(eventType) = Noop: isNewest{i};
    esac;
  """
    print(template[1 : -1], end="")
    if i != numNode - 1:
      print()
  ⟩⟩⟩

  ⟨⟨⟨ python
  print("\n".join([f"init(voteAcpt{i}) := FALSE;" for i in range(⟨=numNode⟩)]), end="")
  ⟩⟩⟩

  ⟨⟨⟨ python
  for i in range(⟨=numNode⟩):
    template = \
  f"""
  next(voteAcpt{i}) := case
    next(eventType) = VoteRsp & next(eventSenderID = {i}) : TRUE;
    next(node{i}.role = Candidate) : TRUE;
    !isNewest{i} & next(isNewest{i}) : FALSE;
    TRUE : voteAcpt{i};
  esac;
  """
    print(template[1 : -1], end="")
    if i != ⟨=numNode⟩ - 1:
      print()
  ⟩⟩⟩


-- 几种事件都有可能发生
CTLSPEC EF(eventType = Timeout)
CTLSPEC EF(eventType = VoteReq)
CTLSPEC EF(eventType = VoteRsp)
-- 总是有节点处于最新的状态
CTLSPEC AG(⟨!python -c "print(' | '.join([f'isNewest{i}' for i in range(⟨=numNode⟩)]))"⟩)
-- 总是有节点可以赢得大部分选票
CTLSPEC EF(oracleWinMajority)
-- 每个节点都可能处于三种状态之一
CTLSPEC EF(node0.role = Follower);
CTLSPEC EF(node0.role = Candidate);
CTLSPEC EF(node0.role = Leader);
-- 每个节点都可以给自己或其他某个节点投票
CTLSPEC EF(node0.votedFor = -1)
CTLSPEC EF(node0.votedFor = 0)
CTLSPEC EF(node0.votedFor = 1)
-- 一个 candidate 总是可以立即发起投票请求
CTLSPEC AG(node0.role = Candidate -> EX (eventType = VoteReq))
-- 一个已经投票的 follower 总是可以立即发送投票响应
CTLSPEC AG(node0.role = Follower & node0.votedFor != -1 -> (EX eventType = VoteRsp))
-- 在第一个 leader 被选出来之前一定发生过 VoteReq
CTLSPEC !E[eventType != VoteReq U node0.role = Leader]
-- 在第一个 leader 被选出来之前一定发生过 VoteRsp（这个性质只有在系统节点数不小于 5 时才有意义）
CTLSPEC !E[eventType != VoteRsp U node0.role = Leader]
-- 有可能出现系统中多个节点处于 leader 状态的情况
CTLSPEC EF(node0.role = Leader & node1.role = Leader)
-- 如果当前存在一个处于最新任期的 leader，那么其他节点不可能立即变成 leader
CTLSPEC AG(node0.role = Leader & isNewest0 & node1.role != Leader -> AX node1.role != Leader)
-- 弱化的 election safety 属性：不可能有两个同时都是处于最新任期的 leader
CTLSPEC !AG(isNewest0 & isNewest1 & node0.role = Leader & node1.role = Leader)

